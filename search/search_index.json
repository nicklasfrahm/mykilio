{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"","title":"Home"},{"location":"contributing.html","text":"Contributing \u00b6 We would love for you to contribute. If you decide to do so, please have a look at this document about some conventions and practical hints. FreeCAD \u00b6 When developing mechanical parts with FreeCAD, there are some things that should be considered regarding the internal structure of the mechanical parts: If you create assemblies, please use the Assembly 4 addon workbench in KiCAD. When attaching parts inside assemblies, try to minimize the usage of offsets. This can be done by using attachment methods, such as Concentric or Align O-X-Y . If the file is a result of a .step -file import, create a compound with the KiCAD StepUp addon workbench. Afterwards, create a new part and move the single shape into the part. Finally, delete all intermediate and hidden parts that were created in the process.","title":"Contributing"},{"location":"contributing.html#contributing","text":"We would love for you to contribute. If you decide to do so, please have a look at this document about some conventions and practical hints.","title":"Contributing"},{"location":"contributing.html#freecad","text":"When developing mechanical parts with FreeCAD, there are some things that should be considered regarding the internal structure of the mechanical parts: If you create assemblies, please use the Assembly 4 addon workbench in KiCAD. When attaching parts inside assemblies, try to minimize the usage of offsets. This can be done by using attachment methods, such as Concentric or Align O-X-Y . If the file is a result of a .step -file import, create a compound with the KiCAD StepUp addon workbench. Afterwards, create a new part and move the single shape into the part. Finally, delete all intermediate and hidden parts that were created in the process.","title":"FreeCAD"},{"location":"cremini-blade-atmega328p.html","text":"Blade (ATmega328P) \u00b6 This variant of the blade is based on the very popular ATmega328P microcontroller that is also used in the Arduino Uno and the Arduino Nano. Due to its usage as a microcontroller on these popular developer boards, it has a well-established online community, which provides a lot of resources on how to develop applications with this microcontroller. Electronics \u00b6 The electronic schematic of the PCB can be found here . Firmware \u00b6 To build the firmware, start the development container and run: make If you are using Windows or WSL 2, you can download AVRDUDE for Windows . Install it by placing the files from the archive in C:\\Windows\\System32 and renaming avrdude.exe to avrdude . Now you can open your repository folder in Git Bash or WSL 2 and run: PORT = COM3 make flash Note: You can't flash from within the development container. So make sure to run make in your development container first before flashing the firmware with make flash from outside your container. To clean the build artifacts, run: make clean Connection issues \u00b6 If you are not able to flash the firmware to the device, this may have several reasons. One potential cause can be a missing, bricked or outdated bootloader. Make sure you are using the most recent bootloader by having a look at the bootloader section . If you don't feel comfortable updating the bootloader and you are sure that the board has a bootloader installed, the issue could be caused by a BAUD mismatch of the bootloader and the programmer. By default the Makefile will use a BAUD of 115200 to be compatible with the bootloader that is part of this repository. Some older devices however come with an old bootloader that only supports a BAUD of 57600 . You can adjust the BAUD by changing the command to: PORT = COM3 BAUD = 57600 make flash Bootloader \u00b6 If the board is factory-new, it does not have a bootloader installed. Therefore it is not possible to install any firmware via the USB to serial interface. The bootloader can be installed via the in-circuit serial programming (ICSP) header by the help of an in-system programmer. For this example, we will use two Arduino Nanos with an ATmega328P, because this will come very close to flashing the bootloader to the actual board via the ISCP header. The programmer has the most recent bootloader installed and therefore uses a BAUD of 115200 . The target has no bootloader or an old version installed. Begin by wiring up the ICSP headers of the Arduinos as shown in the diagram below. The first command will install the Arduino ISP programmer firmware on the programmer Arduino. PORT = COM3 make isp The second command will install the bootloader by first setting the fuses for the clock configuration and other important settings and then flashing the Optiboot bootloader onto the device. PORT = COM3 make burn Acknowledgements \u00b6 I would like to thank Kasper Laursen ( @Clapfire ) for teaching me how to use KiCAD as well as Christian Mai for reviewing my schematic design and giving me invaluable feedback to improve the board design.","title":"Blade (ATmega328P)"},{"location":"cremini-blade-atmega328p.html#blade-atmega328p","text":"This variant of the blade is based on the very popular ATmega328P microcontroller that is also used in the Arduino Uno and the Arduino Nano. Due to its usage as a microcontroller on these popular developer boards, it has a well-established online community, which provides a lot of resources on how to develop applications with this microcontroller.","title":"Blade (ATmega328P)"},{"location":"cremini-blade-atmega328p.html#electronics","text":"The electronic schematic of the PCB can be found here .","title":"Electronics"},{"location":"cremini-blade-atmega328p.html#firmware","text":"To build the firmware, start the development container and run: make If you are using Windows or WSL 2, you can download AVRDUDE for Windows . Install it by placing the files from the archive in C:\\Windows\\System32 and renaming avrdude.exe to avrdude . Now you can open your repository folder in Git Bash or WSL 2 and run: PORT = COM3 make flash Note: You can't flash from within the development container. So make sure to run make in your development container first before flashing the firmware with make flash from outside your container. To clean the build artifacts, run: make clean","title":"Firmware"},{"location":"cremini-blade-atmega328p.html#connection-issues","text":"If you are not able to flash the firmware to the device, this may have several reasons. One potential cause can be a missing, bricked or outdated bootloader. Make sure you are using the most recent bootloader by having a look at the bootloader section . If you don't feel comfortable updating the bootloader and you are sure that the board has a bootloader installed, the issue could be caused by a BAUD mismatch of the bootloader and the programmer. By default the Makefile will use a BAUD of 115200 to be compatible with the bootloader that is part of this repository. Some older devices however come with an old bootloader that only supports a BAUD of 57600 . You can adjust the BAUD by changing the command to: PORT = COM3 BAUD = 57600 make flash","title":"Connection issues"},{"location":"cremini-blade-atmega328p.html#bootloader","text":"If the board is factory-new, it does not have a bootloader installed. Therefore it is not possible to install any firmware via the USB to serial interface. The bootloader can be installed via the in-circuit serial programming (ICSP) header by the help of an in-system programmer. For this example, we will use two Arduino Nanos with an ATmega328P, because this will come very close to flashing the bootloader to the actual board via the ISCP header. The programmer has the most recent bootloader installed and therefore uses a BAUD of 115200 . The target has no bootloader or an old version installed. Begin by wiring up the ICSP headers of the Arduinos as shown in the diagram below. The first command will install the Arduino ISP programmer firmware on the programmer Arduino. PORT = COM3 make isp The second command will install the bootloader by first setting the fuses for the clock configuration and other important settings and then flashing the Optiboot bootloader onto the device. PORT = COM3 make burn","title":"Bootloader"},{"location":"cremini-blade-atmega328p.html#acknowledgements","text":"I would like to thank Kasper Laursen ( @Clapfire ) for teaching me how to use KiCAD as well as Christian Mai for reviewing my schematic design and giving me invaluable feedback to improve the board design.","title":"Acknowledgements"},{"location":"cremini-management-bus-interface.html","text":"Management bus interface \u00b6 With the default open-source firmware the individual blades can be controlled via a TWI (I 2 C) communication bus . The blades use 5V CMOS logic levels for the TWI signals (SDA, SCL) on the management bus. Address structure \u00b6 All registers are addressed via 8-bit addresses, which follow a common scheme as described in the table below. Bits Name Description [7:4] Data category A 4-bit identifier that corresponds to a data category . [3:0] Register address A 4-bit address for a register within a data category . Data framing \u00b6 The reader is expected to have basic familiarity with the principles and bus states of TWI. SDA is the serial data line, while SCL is the serial clock line. A signal is a bus event, such as START or ACK , whereas an operation is the combination of signals between two START signals or the last START and the STOP signal . A transaction in contrast is the combination of signals between the first START and STOP signal . Independent of the fact if it is a read or a write transaction , the following operations are performed to interact with remote register via TWI. The client sends START signal by pulling SDA low, while SCL is high. The client writes the server address byte to the bus, which specifies the server it would like to address. The least significant bit of this byte is the R/W bit . If it is set to 1 it indicates a read operation , whereas if it is set to 0 , it indicates a write operation . The server acknowledges the receival by pulling SDA low when SCL is high and therefore sending an ACK signal. The client sends the register address byte to the bus, which indicates the register address it wants to write to. This must be 0x00 if a read transaction is to be performed. Writing to register address 0x00 sets the _ address pointer on the server and thus indicating the location of the next read operation . The server sends an ACK signal. a. If it is a write transaction , the following steps are performed after step 5: The client sends n more data bytes , which are each acknowlegded by the server. The client sends a STOP condition by releasing the SDA line to a high signal, while SCL is high. b. In contrast, if it is a read transaction , the following step are further performed after step 5: The client sends a single data byte containing the register address to be read to the server and the server sends an ACK signal. The client sends another START signal, often also referred to as REPEATED START by pulling SDA low while SCL is high. The client sends the address byte with the R/W bit set to 1 to indicate a read operation. The server sends an ACK signal. Now the server sends n data bytes , which are each acknowlegded by the server with an ACK signal. The transaction is ended by the client sending a NACK signal to request the server to release the bus. This is then followed up by the client sending a STOP condition. Register overview \u00b6 This section describes all available register addresses that are part of the interface. The Access column specifies the access to the register, which can be either RW indicating read-write access or RO indicating read-only access. The Datatype column indirectly specifies the register length in bytes via the datatype expected to be read from or written to the specified register. All registers use most significant byte first byte ordering. Metadata registers \u00b6 Register Address Datatype Access Name Description ADRPTR 0x00 uint8 RW Address pointer The register address of the next read or write operation. Status registers \u00b6 Register Address Datatype Access Name Description BMCSTA 0x10 uint8 RO BMC 1 state The state of the baseboard management controller enumerated as described here . SBCSTA 0x11 uint8 RO SBC 2 state The state of the single board controller enumerated as described here . PSUSTA 0x12 uint8 RO PSU 3 state The state of the external power supply enumerated as described here . FANDCC 0x13 uint8 RO DC 4 fan state The state of the DC controlled fan enumerated as described here . FANPWM 0x14 uint8 RO PWM 5 fan state The state of the PWM controlled fan enumerated as described here . FANMIN 0x15 uint8 RO Minimum fan speed The minimum rotational speed of the fan in Hertz before entering the stop band. FANMAX 0x16 uint8 RO Maximum fan speed The maximum rotational speed of the fan in Hertz at full power. DUTMIN 0x17 uint8 RO Minimum fan duty The minimum duty cycle of the fan control signal before entering the stop band. DUTMAX 0x18 uint8 RO Maximum fan duty The maximum duty cycle of the fan control signal at full power. BMCCPU 0x19 char[16] RO BMC CPU 6 A string providing the CPU name of the BMC. BMCFWN 0x20 char[16] RO BMC firmware name A string providing the name of the installed firmware. BMCFWV 0x21 char[16] RO BMC firmware version A string providing the semantic version of the firmware. Specification registers \u00b6 Register Address Datatype Access Name Description SBCPON 0x30 uint8 RW SBC power-on The desired state of the single-board computer power rail enumerated as described here . SBCSON 0x31 uint8 RW SBC soft-on The desired state of the single-board computer enumerated as described here . FANMOD 0x32 uint8 RW Fan control mode The mode used to control the fan enumerated as described here . FANFDB 0x33 uint8 RW Fan feedback source The feedback source of the automatic fan control mode as described here . FANSET 0x34 uint8 RW Fan setpoint The sensor range percentage at which the fan should run with full speed. FANMAN 0x35 uint8 RW Fan manual setpoint The duty setpoint for the fan in manual mode. LEDMOD 0x36 uint8 RW LED control mode The mode used to control the LED enumerated as described here . LEDFDB 0x37 uint8 RW LED feedback source The feedback source of the automatic LED control mode as described here . LEDSET 0x38 uint8 RW LED setpoint The sensor range percentage at which the LED should light up with full brightness. LEDMAN 0x39 uint8 RW LED manual setpoint The duty setpoint for the LED in manual mode. Telemetry registers \u00b6 Register Address Datatype Access Name Description FANSPD 0x50 uint8 RO Fan speed The current fan speed in Hertz. FANDUT 0x51 uint8 RO Fan duty cycle The current fan duty cycle. BMCVOL 0x52 float RO BMC voltage The current drawn by the baseboard management controller and all other electronics. BMCCUR 0x53 float RO BMC current The voltage supplied to the baseboard management controller and all other electronics. SBCVOL 0x54 float RO SBC voltage The current drawn by the single-board computer. SBCCUR 0x55 float RO SBC current The voltage supplied to the single-board computer. TMPAMB 0x56 float RO Ambient temperature The ambient temperature. TMPPSU 0x57 float RO PSU temperature The temperature of the power supply or the VIN rail trace and is based on the backplane. Action registers \u00b6 Register Address Datatype Access Name Description ACTPCY 0x70 uint8 RW Power-cycle action Power-cycle the single-board computer by disconnecting and reconnecting the power. ACTREB 0x71 uint8 RW Reboot action Reboot the single-board computer by halting it via GPIO 7 and restarting it. ACTENU 0x72 uint8 RW Hardware enumeration action Enumerate the connected hardware and update the status. Register description \u00b6 The following section explains more detailed how the register values are to be interpreted. SBCPON \u00b6 This register controls the power rail of the single-board computer. Writing a value of M6M_STATE_DISABLED or 2 to this register will disable the power rail, while writing a value of M6M_STATE_ENABLED or 3 to the register will enable the power rail. Other values are ignored and have no effect. Danger: Potential data loss Interrupting power without shutting the single-board computer down may cause data loss, especially if the storage medium is an SD card. Please consider using the soft-on ( SBCSON ) register instead. SBCSON \u00b6 This register controls the system state of the single board computer via a GPIO. Writing a value of M6M_STATE_DISABLED or 2 to this register will ensure that the single-board computer is off, while writing a value of M6M_STATE_ENABLED or 3 to the register will ensure that the single-board computer is on. Note: Limited support Not all single board computers support this. Currently this is only known to be working for the Raspberry Pi with the gpio-shutdown devicetree overlay . FANMOD \u00b6 The fan control mode of the fan can be automatic, where x is the feedback signal as configured by FANFDB and a is automatically calculated based on the configuration of the fan setpoint ( FANSET ) register. Mode Value Description Off 0 The fan is disabled. Manual 1 The fan is controlled by writing a value to the FANMAN register. Linear 2 The fan is controlled according to the function f(x) = a*x . SquareRoot 3 The fan is controlled according to the function f(x) = a*sqrt(x) . Quadratic 4 The fan is controlled according to the function f(x) = a*x^2 . Exponential 5 The fan is controlled according to the function f(x) = a*e^x . FANFDB \u00b6 The fan feedback source that is used to compute the duty for any fan control mode other than Off or Manual . Feedback source Value Minimum sensor value Maximum sensor value Ambient temperature 0 0\u00b0C 100\u00b0C PSU temperature 1 0\u00b0C 100\u00b0C BMC current 2 0A 5A SBC current 3 0A 5A FANSET \u00b6 The fan setpoint configures the value at which the fan will run with full speed. This value is used to compute the parameter a if the fan control mode ( FANMOD ) is not Off or Manual . The fan setpoint is a percentage of the full-range sensor maximum and therefore unitless irrespective of which feedback source ( FANFDB ) is selected. Example: Controlling the fan based on a temperature measurement Let's assume that we want don't want our CPU to overheat. Our requirement is that we want to run the fan at full speed if the ambient temperature sensor reads a value above 40\u00b0C. The maximum sensor value is of this sensor is 100\u00b0C as described here . To determine the register value, we can use the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> #include <stdio.h> int calc_fanset ( float setpoint , float sensor_max ) { float setpoint_percent = setpoint / sensor_max ; return ( int ) floor ( setpoint_percent * 255 ); } int main ( void ) { float temperature_setpoint = 40 ; float sensor_max = 100 ; printf ( \"Full-speed temperature: %.0f\u00b0C \\n \" , temperature_setpoint ); printf ( \"Fan setpoint: %d \\n \" , calc_fanset ( temperature_setpoint , sensor_max )); return 0 ; } Create a file called calc.c , paste the code above and run gcc -o calc calc.c -lm && ./calc && rm calc . You should get the following output: Full-speed temperature: 40\u00b0C Fan setpoint: 102 By writing the value 102 to our FANSET register, the fan will now run on full speed if the sensor reads 40\u00b0C. Example: Controlling the fan based on compute load Let's assume that we want to run our fan based on the compute load of the single board computer. We can indirectly measure the load by observing the current draw, so our requirement is that we our fan to run at full speed if the current sensor reads a value above 1.5A. The maximum sensor value is of this sensor is 5A as described here . To determine the register value, we can use the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> #include <stdio.h> int calc_fanset ( float setpoint , float sensor_max ) { float setpoint_percent = setpoint / sensor_max ; return ( int ) floor ( setpoint_percent * 255 ); } int main ( void ) { float current_setpoint = 1.5 ; float sensor_max = 5 ; printf ( \"Full-speed power: %.1fW \\n \" , current_setpoint * 5 ); printf ( \"Fan setpoint: %d \\n \" , calc_fanset ( current_setpoint , sensor_max )); return 0 ; } Create a file called calc.c , paste the code above and run gcc -o calc calc.c -lm && ./calc && rm calc . You should get the following output: Full-speed power: 7.5W Fan setpoint: 76 By writing the value 76 to our FANSET register, the fan will now run on full speed if the sensor reads 1.5A. FANMAN \u00b6 Writing a value to this register will set the duty of the fan if the fan mode ( FANMOD ) is set to Manual . 0 corresponds to a duty of 0%, while 255 corresponds to 100%. Any value between 0 and 255 is valid. LEDMOD \u00b6 Please use the FANMOD register configuration reference as the LED control mode register accepts the same options. LEDFDB \u00b6 Please use the FANFDB register configuration reference as the LED feedback source register accepts the same options. LEDSET \u00b6 Please use the FANSET register configuration reference as the LED setpoint register accepts the same options. LEDMAN \u00b6 Please use the FANMAN register configuration reference as the LED manual override register accepts the same options. ACTPCY \u00b6 Writing any value other than 0 to this register will issue a power-cycle of the single-board computer. Danger: Potential data loss Issuing a power-cycle may cause data loss, especially if the storage medium is an SD card. Please consider using the reboot action ( ACTREB ) instead. ACTREB \u00b6 Writing any value other than 0 to this register will issue a soft reboot of the single-board computer using a GPIO pin. Note: Limited support Not all single board computers support this. Currently this is only known to be working for the Raspberry Pi with the gpio-shutdown devicetree overlay . ACTENU \u00b6 Writing any value other than 0 to this register will start an enumeration process that will gather the information for most of the status registers described earlier. Libraries \u00b6 To interface with the blade via the management bus interface, the following libraries are provided: C / C++: mushroom.h . BMC: baseboard management controller \u21a9 SBC: single-board computer \u21a9 PSU: power supply unit \u21a9 DC: direct current \u21a9 PWM: pulse-width modulation \u21a9 CPU: central processing unit \u21a9 GPIO: general-purpose input/output \u21a9","title":"Management bus interface"},{"location":"cremini-management-bus-interface.html#management-bus-interface","text":"With the default open-source firmware the individual blades can be controlled via a TWI (I 2 C) communication bus . The blades use 5V CMOS logic levels for the TWI signals (SDA, SCL) on the management bus.","title":"Management bus interface"},{"location":"cremini-management-bus-interface.html#address-structure","text":"All registers are addressed via 8-bit addresses, which follow a common scheme as described in the table below. Bits Name Description [7:4] Data category A 4-bit identifier that corresponds to a data category . [3:0] Register address A 4-bit address for a register within a data category .","title":"Address structure"},{"location":"cremini-management-bus-interface.html#data-framing","text":"The reader is expected to have basic familiarity with the principles and bus states of TWI. SDA is the serial data line, while SCL is the serial clock line. A signal is a bus event, such as START or ACK , whereas an operation is the combination of signals between two START signals or the last START and the STOP signal . A transaction in contrast is the combination of signals between the first START and STOP signal . Independent of the fact if it is a read or a write transaction , the following operations are performed to interact with remote register via TWI. The client sends START signal by pulling SDA low, while SCL is high. The client writes the server address byte to the bus, which specifies the server it would like to address. The least significant bit of this byte is the R/W bit . If it is set to 1 it indicates a read operation , whereas if it is set to 0 , it indicates a write operation . The server acknowledges the receival by pulling SDA low when SCL is high and therefore sending an ACK signal. The client sends the register address byte to the bus, which indicates the register address it wants to write to. This must be 0x00 if a read transaction is to be performed. Writing to register address 0x00 sets the _ address pointer on the server and thus indicating the location of the next read operation . The server sends an ACK signal. a. If it is a write transaction , the following steps are performed after step 5: The client sends n more data bytes , which are each acknowlegded by the server. The client sends a STOP condition by releasing the SDA line to a high signal, while SCL is high. b. In contrast, if it is a read transaction , the following step are further performed after step 5: The client sends a single data byte containing the register address to be read to the server and the server sends an ACK signal. The client sends another START signal, often also referred to as REPEATED START by pulling SDA low while SCL is high. The client sends the address byte with the R/W bit set to 1 to indicate a read operation. The server sends an ACK signal. Now the server sends n data bytes , which are each acknowlegded by the server with an ACK signal. The transaction is ended by the client sending a NACK signal to request the server to release the bus. This is then followed up by the client sending a STOP condition.","title":"Data framing"},{"location":"cremini-management-bus-interface.html#register-overview","text":"This section describes all available register addresses that are part of the interface. The Access column specifies the access to the register, which can be either RW indicating read-write access or RO indicating read-only access. The Datatype column indirectly specifies the register length in bytes via the datatype expected to be read from or written to the specified register. All registers use most significant byte first byte ordering.","title":"Register overview"},{"location":"cremini-management-bus-interface.html#metadata-registers","text":"Register Address Datatype Access Name Description ADRPTR 0x00 uint8 RW Address pointer The register address of the next read or write operation.","title":"Metadata registers"},{"location":"cremini-management-bus-interface.html#status-registers","text":"Register Address Datatype Access Name Description BMCSTA 0x10 uint8 RO BMC 1 state The state of the baseboard management controller enumerated as described here . SBCSTA 0x11 uint8 RO SBC 2 state The state of the single board controller enumerated as described here . PSUSTA 0x12 uint8 RO PSU 3 state The state of the external power supply enumerated as described here . FANDCC 0x13 uint8 RO DC 4 fan state The state of the DC controlled fan enumerated as described here . FANPWM 0x14 uint8 RO PWM 5 fan state The state of the PWM controlled fan enumerated as described here . FANMIN 0x15 uint8 RO Minimum fan speed The minimum rotational speed of the fan in Hertz before entering the stop band. FANMAX 0x16 uint8 RO Maximum fan speed The maximum rotational speed of the fan in Hertz at full power. DUTMIN 0x17 uint8 RO Minimum fan duty The minimum duty cycle of the fan control signal before entering the stop band. DUTMAX 0x18 uint8 RO Maximum fan duty The maximum duty cycle of the fan control signal at full power. BMCCPU 0x19 char[16] RO BMC CPU 6 A string providing the CPU name of the BMC. BMCFWN 0x20 char[16] RO BMC firmware name A string providing the name of the installed firmware. BMCFWV 0x21 char[16] RO BMC firmware version A string providing the semantic version of the firmware.","title":"Status registers"},{"location":"cremini-management-bus-interface.html#specification-registers","text":"Register Address Datatype Access Name Description SBCPON 0x30 uint8 RW SBC power-on The desired state of the single-board computer power rail enumerated as described here . SBCSON 0x31 uint8 RW SBC soft-on The desired state of the single-board computer enumerated as described here . FANMOD 0x32 uint8 RW Fan control mode The mode used to control the fan enumerated as described here . FANFDB 0x33 uint8 RW Fan feedback source The feedback source of the automatic fan control mode as described here . FANSET 0x34 uint8 RW Fan setpoint The sensor range percentage at which the fan should run with full speed. FANMAN 0x35 uint8 RW Fan manual setpoint The duty setpoint for the fan in manual mode. LEDMOD 0x36 uint8 RW LED control mode The mode used to control the LED enumerated as described here . LEDFDB 0x37 uint8 RW LED feedback source The feedback source of the automatic LED control mode as described here . LEDSET 0x38 uint8 RW LED setpoint The sensor range percentage at which the LED should light up with full brightness. LEDMAN 0x39 uint8 RW LED manual setpoint The duty setpoint for the LED in manual mode.","title":"Specification registers"},{"location":"cremini-management-bus-interface.html#telemetry-registers","text":"Register Address Datatype Access Name Description FANSPD 0x50 uint8 RO Fan speed The current fan speed in Hertz. FANDUT 0x51 uint8 RO Fan duty cycle The current fan duty cycle. BMCVOL 0x52 float RO BMC voltage The current drawn by the baseboard management controller and all other electronics. BMCCUR 0x53 float RO BMC current The voltage supplied to the baseboard management controller and all other electronics. SBCVOL 0x54 float RO SBC voltage The current drawn by the single-board computer. SBCCUR 0x55 float RO SBC current The voltage supplied to the single-board computer. TMPAMB 0x56 float RO Ambient temperature The ambient temperature. TMPPSU 0x57 float RO PSU temperature The temperature of the power supply or the VIN rail trace and is based on the backplane.","title":"Telemetry registers"},{"location":"cremini-management-bus-interface.html#action-registers","text":"Register Address Datatype Access Name Description ACTPCY 0x70 uint8 RW Power-cycle action Power-cycle the single-board computer by disconnecting and reconnecting the power. ACTREB 0x71 uint8 RW Reboot action Reboot the single-board computer by halting it via GPIO 7 and restarting it. ACTENU 0x72 uint8 RW Hardware enumeration action Enumerate the connected hardware and update the status.","title":"Action registers"},{"location":"cremini-management-bus-interface.html#register-description","text":"The following section explains more detailed how the register values are to be interpreted.","title":"Register description"},{"location":"cremini-management-bus-interface.html#sbcpon","text":"This register controls the power rail of the single-board computer. Writing a value of M6M_STATE_DISABLED or 2 to this register will disable the power rail, while writing a value of M6M_STATE_ENABLED or 3 to the register will enable the power rail. Other values are ignored and have no effect. Danger: Potential data loss Interrupting power without shutting the single-board computer down may cause data loss, especially if the storage medium is an SD card. Please consider using the soft-on ( SBCSON ) register instead.","title":"SBCPON"},{"location":"cremini-management-bus-interface.html#sbcson","text":"This register controls the system state of the single board computer via a GPIO. Writing a value of M6M_STATE_DISABLED or 2 to this register will ensure that the single-board computer is off, while writing a value of M6M_STATE_ENABLED or 3 to the register will ensure that the single-board computer is on. Note: Limited support Not all single board computers support this. Currently this is only known to be working for the Raspberry Pi with the gpio-shutdown devicetree overlay .","title":"SBCSON"},{"location":"cremini-management-bus-interface.html#fanmod","text":"The fan control mode of the fan can be automatic, where x is the feedback signal as configured by FANFDB and a is automatically calculated based on the configuration of the fan setpoint ( FANSET ) register. Mode Value Description Off 0 The fan is disabled. Manual 1 The fan is controlled by writing a value to the FANMAN register. Linear 2 The fan is controlled according to the function f(x) = a*x . SquareRoot 3 The fan is controlled according to the function f(x) = a*sqrt(x) . Quadratic 4 The fan is controlled according to the function f(x) = a*x^2 . Exponential 5 The fan is controlled according to the function f(x) = a*e^x .","title":"FANMOD"},{"location":"cremini-management-bus-interface.html#fanfdb","text":"The fan feedback source that is used to compute the duty for any fan control mode other than Off or Manual . Feedback source Value Minimum sensor value Maximum sensor value Ambient temperature 0 0\u00b0C 100\u00b0C PSU temperature 1 0\u00b0C 100\u00b0C BMC current 2 0A 5A SBC current 3 0A 5A","title":"FANFDB"},{"location":"cremini-management-bus-interface.html#fanset","text":"The fan setpoint configures the value at which the fan will run with full speed. This value is used to compute the parameter a if the fan control mode ( FANMOD ) is not Off or Manual . The fan setpoint is a percentage of the full-range sensor maximum and therefore unitless irrespective of which feedback source ( FANFDB ) is selected. Example: Controlling the fan based on a temperature measurement Let's assume that we want don't want our CPU to overheat. Our requirement is that we want to run the fan at full speed if the ambient temperature sensor reads a value above 40\u00b0C. The maximum sensor value is of this sensor is 100\u00b0C as described here . To determine the register value, we can use the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> #include <stdio.h> int calc_fanset ( float setpoint , float sensor_max ) { float setpoint_percent = setpoint / sensor_max ; return ( int ) floor ( setpoint_percent * 255 ); } int main ( void ) { float temperature_setpoint = 40 ; float sensor_max = 100 ; printf ( \"Full-speed temperature: %.0f\u00b0C \\n \" , temperature_setpoint ); printf ( \"Fan setpoint: %d \\n \" , calc_fanset ( temperature_setpoint , sensor_max )); return 0 ; } Create a file called calc.c , paste the code above and run gcc -o calc calc.c -lm && ./calc && rm calc . You should get the following output: Full-speed temperature: 40\u00b0C Fan setpoint: 102 By writing the value 102 to our FANSET register, the fan will now run on full speed if the sensor reads 40\u00b0C. Example: Controlling the fan based on compute load Let's assume that we want to run our fan based on the compute load of the single board computer. We can indirectly measure the load by observing the current draw, so our requirement is that we our fan to run at full speed if the current sensor reads a value above 1.5A. The maximum sensor value is of this sensor is 5A as described here . To determine the register value, we can use the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> #include <stdio.h> int calc_fanset ( float setpoint , float sensor_max ) { float setpoint_percent = setpoint / sensor_max ; return ( int ) floor ( setpoint_percent * 255 ); } int main ( void ) { float current_setpoint = 1.5 ; float sensor_max = 5 ; printf ( \"Full-speed power: %.1fW \\n \" , current_setpoint * 5 ); printf ( \"Fan setpoint: %d \\n \" , calc_fanset ( current_setpoint , sensor_max )); return 0 ; } Create a file called calc.c , paste the code above and run gcc -o calc calc.c -lm && ./calc && rm calc . You should get the following output: Full-speed power: 7.5W Fan setpoint: 76 By writing the value 76 to our FANSET register, the fan will now run on full speed if the sensor reads 1.5A.","title":"FANSET"},{"location":"cremini-management-bus-interface.html#fanman","text":"Writing a value to this register will set the duty of the fan if the fan mode ( FANMOD ) is set to Manual . 0 corresponds to a duty of 0%, while 255 corresponds to 100%. Any value between 0 and 255 is valid.","title":"FANMAN"},{"location":"cremini-management-bus-interface.html#ledmod","text":"Please use the FANMOD register configuration reference as the LED control mode register accepts the same options.","title":"LEDMOD"},{"location":"cremini-management-bus-interface.html#ledfdb","text":"Please use the FANFDB register configuration reference as the LED feedback source register accepts the same options.","title":"LEDFDB"},{"location":"cremini-management-bus-interface.html#ledset","text":"Please use the FANSET register configuration reference as the LED setpoint register accepts the same options.","title":"LEDSET"},{"location":"cremini-management-bus-interface.html#ledman","text":"Please use the FANMAN register configuration reference as the LED manual override register accepts the same options.","title":"LEDMAN"},{"location":"cremini-management-bus-interface.html#actpcy","text":"Writing any value other than 0 to this register will issue a power-cycle of the single-board computer. Danger: Potential data loss Issuing a power-cycle may cause data loss, especially if the storage medium is an SD card. Please consider using the reboot action ( ACTREB ) instead.","title":"ACTPCY"},{"location":"cremini-management-bus-interface.html#actreb","text":"Writing any value other than 0 to this register will issue a soft reboot of the single-board computer using a GPIO pin. Note: Limited support Not all single board computers support this. Currently this is only known to be working for the Raspberry Pi with the gpio-shutdown devicetree overlay .","title":"ACTREB"},{"location":"cremini-management-bus-interface.html#actenu","text":"Writing any value other than 0 to this register will start an enumeration process that will gather the information for most of the status registers described earlier.","title":"ACTENU"},{"location":"cremini-management-bus-interface.html#libraries","text":"To interface with the blade via the management bus interface, the following libraries are provided: C / C++: mushroom.h . BMC: baseboard management controller \u21a9 SBC: single-board computer \u21a9 PSU: power supply unit \u21a9 DC: direct current \u21a9 PWM: pulse-width modulation \u21a9 CPU: central processing unit \u21a9 GPIO: general-purpose input/output \u21a9","title":"Libraries"},{"location":"cremini-overview.html","text":"Cremini \u00b6 Cremini is an open source, open hardware blade server. It can take several single board computers that are pin-compatible with the Raspberry Pi and follow the hardware dimensions of the Model B variant of the Raspberry Pi. Features \u00b6 Flexibility Modular design: Start with a single node and scale up to 16 Hackable hardware: Write your own custom firmware for the blade Raspberry Pi support: Connect any development board compatible with the Raspberry Pi Built-in LED: Give custom status feedback Node management Soft power-on and power-off Hard reset via power-disconnect Serial connection passthrough Sensors Current and voltage probes for single board computer and blade Single board computer connection detection Power supply and ambient temperature probes Chassis fan (optional) Standard 4-pin PWM fan header PWM or DC fan control Automatic control mode selection via power-on self test (POST) Reliability USB backpower protection ICSP header for bootloader flashing Components \u00b6 The blade server is used as a hardware platform for the reference implementation of the Mycelium API and it consists of the following components: Blade: A board that is attached directly to the GPIO header of the single board computer. It monitors power usage, controls the power state and can be controlled via TWI (I 2 C). Currently the following variants of the blade are available: Blade (ATmega328P) Backplane: A board to supply the blade and the single board computers with power and connect them to a management bus. The backplane is available in the following variants: Backplane (TPS54560) Backplane (TPS54561) Backplane (DM28) Roadmap \u00b6 Manager card : An ESP32 based PCB that connects to the backplane management bus and implements the Mycelium API for the blades. Redundant power supply backplane : A PCB that connects to the backplane management bus and allows to connect two redundant power supplies to be connected and controlled via the controller board.","title":"Overview"},{"location":"cremini-overview.html#cremini","text":"Cremini is an open source, open hardware blade server. It can take several single board computers that are pin-compatible with the Raspberry Pi and follow the hardware dimensions of the Model B variant of the Raspberry Pi.","title":"Cremini"},{"location":"cremini-overview.html#features","text":"Flexibility Modular design: Start with a single node and scale up to 16 Hackable hardware: Write your own custom firmware for the blade Raspberry Pi support: Connect any development board compatible with the Raspberry Pi Built-in LED: Give custom status feedback Node management Soft power-on and power-off Hard reset via power-disconnect Serial connection passthrough Sensors Current and voltage probes for single board computer and blade Single board computer connection detection Power supply and ambient temperature probes Chassis fan (optional) Standard 4-pin PWM fan header PWM or DC fan control Automatic control mode selection via power-on self test (POST) Reliability USB backpower protection ICSP header for bootloader flashing","title":"Features"},{"location":"cremini-overview.html#components","text":"The blade server is used as a hardware platform for the reference implementation of the Mycelium API and it consists of the following components: Blade: A board that is attached directly to the GPIO header of the single board computer. It monitors power usage, controls the power state and can be controlled via TWI (I 2 C). Currently the following variants of the blade are available: Blade (ATmega328P) Backplane: A board to supply the blade and the single board computers with power and connect them to a management bus. The backplane is available in the following variants: Backplane (TPS54560) Backplane (TPS54561) Backplane (DM28)","title":"Components"},{"location":"cremini-overview.html#roadmap","text":"Manager card : An ESP32 based PCB that connects to the backplane management bus and implements the Mycelium API for the blades. Redundant power supply backplane : A PCB that connects to the backplane management bus and allows to connect two redundant power supplies to be connected and controlled via the controller board.","title":"Roadmap"},{"location":"mykilio-architecture.html","text":"Architecture \u00b6 we have controllers a microservice subscribing to the MQTT broker every controller is also registered as a thing manages state consistency we have things each thing has one or more publicKeys state changes are published to special topic Paths \u00b6 /apis \u00b6 { \"data\" : [ { \"name\" : \"core.mykil.io/v1alpha1\" , \"links\" : [{ \"rel\" : \"self\" , \"href\" : \"/apis/core.mykil.io/v1alpha1\" }] }, { \"name\" : \"baremetal.mykil.io/v1alpha1\" , \"links\" : [{ \"rel\" : \"self\" , \"href\" : \"/apis/baremetal.mykil.io/v1alpha1\" }] } ], \"links\" : [{ \"rel\" : \"self\" , \"href\" : \"/apis\" }] } /apis/core.mykil.io/v1alpha1 \u00b6 { \"data\" : { \"resources\" : [ { \"name\" : \"Namespace\" , \"links\" : [ { \"rel\" : \"self\" , \"href\" : \"/apis/core.mykil.io/v1alpha1/namespaces\" } ] } ] }, \"links\" : [{ \"rel\" : \"self\" , \"href\" : \"/apis/core.mykil.io/v1alpha1\" }] } Concepts \u00b6 This section describes the general concepts and structures behind the API. API groups \u00b6 Mykilio does not expose a single API, but rather aggregates several APIs in so-called API groups. This concept is well-established within the infrastructure management ecosystem and has found widespread adoption due to its successful implementation in Kubernetes. The advantages of structuring an API into API groups, where several versions of an API group can coexist, are outlined in this section of the Kubernetes documentation ). In short, the aggregation of APIs allows for better lifecycle management of APIs with gradual deprecation. Additionally it allows custom vendor-specific APIs to be developed and exposed via the same ecosystem. Namespaces \u00b6 Virtual clusters, zones or regions Protocol mapping \u00b6 Based on which protocol is used, the API groups are mapped to the protocol's native mechanism of representing hierarchies. In the case of HTTP, API groups are mapped to URLs, such as /apis/baremetal.optrin.io/v1alpha1 . Very similarly, the API groups are mapped to topics in MQTT, such as apis/baremetal.optrin.io/v1alpha1 . Please note that there is no leading forward slash ( / ) in MQTT as this may cause confusion as described here ). Ecosystem \u00b6 Let's build something cool together! Libraries \u00b6 To reduce the barrier to adoption, the goal of Mykilio is not only to define the APIs, but also to provide libraries to interact with the APIs. Currently the following languages are considered first class citizens: Go JavaScript C","title":"Architecture"},{"location":"mykilio-architecture.html#architecture","text":"we have controllers a microservice subscribing to the MQTT broker every controller is also registered as a thing manages state consistency we have things each thing has one or more publicKeys state changes are published to special topic","title":"Architecture"},{"location":"mykilio-architecture.html#paths","text":"","title":"Paths"},{"location":"mykilio-architecture.html#apis","text":"{ \"data\" : [ { \"name\" : \"core.mykil.io/v1alpha1\" , \"links\" : [{ \"rel\" : \"self\" , \"href\" : \"/apis/core.mykil.io/v1alpha1\" }] }, { \"name\" : \"baremetal.mykil.io/v1alpha1\" , \"links\" : [{ \"rel\" : \"self\" , \"href\" : \"/apis/baremetal.mykil.io/v1alpha1\" }] } ], \"links\" : [{ \"rel\" : \"self\" , \"href\" : \"/apis\" }] }","title":"/apis"},{"location":"mykilio-architecture.html#apiscoremykiliov1alpha1","text":"{ \"data\" : { \"resources\" : [ { \"name\" : \"Namespace\" , \"links\" : [ { \"rel\" : \"self\" , \"href\" : \"/apis/core.mykil.io/v1alpha1/namespaces\" } ] } ] }, \"links\" : [{ \"rel\" : \"self\" , \"href\" : \"/apis/core.mykil.io/v1alpha1\" }] }","title":"/apis/core.mykil.io/v1alpha1"},{"location":"mykilio-architecture.html#concepts","text":"This section describes the general concepts and structures behind the API.","title":"Concepts"},{"location":"mykilio-architecture.html#api-groups","text":"Mykilio does not expose a single API, but rather aggregates several APIs in so-called API groups. This concept is well-established within the infrastructure management ecosystem and has found widespread adoption due to its successful implementation in Kubernetes. The advantages of structuring an API into API groups, where several versions of an API group can coexist, are outlined in this section of the Kubernetes documentation ). In short, the aggregation of APIs allows for better lifecycle management of APIs with gradual deprecation. Additionally it allows custom vendor-specific APIs to be developed and exposed via the same ecosystem.","title":"API groups"},{"location":"mykilio-architecture.html#namespaces","text":"Virtual clusters, zones or regions","title":"Namespaces"},{"location":"mykilio-architecture.html#protocol-mapping","text":"Based on which protocol is used, the API groups are mapped to the protocol's native mechanism of representing hierarchies. In the case of HTTP, API groups are mapped to URLs, such as /apis/baremetal.optrin.io/v1alpha1 . Very similarly, the API groups are mapped to topics in MQTT, such as apis/baremetal.optrin.io/v1alpha1 . Please note that there is no leading forward slash ( / ) in MQTT as this may cause confusion as described here ).","title":"Protocol mapping"},{"location":"mykilio-architecture.html#ecosystem","text":"Let's build something cool together!","title":"Ecosystem"},{"location":"mykilio-architecture.html#libraries","text":"To reduce the barrier to adoption, the goal of Mykilio is not only to define the APIs, but also to provide libraries to interact with the APIs. Currently the following languages are considered first class citizens: Go JavaScript C","title":"Libraries"},{"location":"mykilio-baremetal-api.html","text":"Baremetal API \u00b6 This API covers most of the features that are required to manage physical infrastructure. It aims to provide resources that provide the same functionality as Redfish or IPMI. Resources \u00b6 API root \u00b6 Manager \u00b6","title":"Baremetal API"},{"location":"mykilio-baremetal-api.html#baremetal-api","text":"This API covers most of the features that are required to manage physical infrastructure. It aims to provide resources that provide the same functionality as Redfish or IPMI.","title":"Baremetal API"},{"location":"mykilio-baremetal-api.html#resources","text":"","title":"Resources"},{"location":"mykilio-baremetal-api.html#api-root","text":"","title":"API root"},{"location":"mykilio-baremetal-api.html#manager","text":"","title":"Manager"},{"location":"mykilio-core-api.html","text":"Core API \u00b6 This API implements basic resources to provide the base for API aggregation, authentication and authorization. The API is located at: HTTPS: /apis/core.mykil.io/v1alpha1 MQTTS: apis/core.mykil.io/v1alpha1 Resources \u00b6 This sections outlines examples of the resources available as part of this API. This document only contains examples. For the actual JSON schema please refer to THIS (TBD) . Public key \u00b6 A public key is used to authenticate things against the platform. They function similarly to the authorized_keys file for on SSH server. apiVersion : baremetal.mykil.io/v1alpha1 kind : PublicKey metadata : name : namespace : spec : signatureScheme : algorithm : ECDSA curve : secp521r1 hash : SHA-512 pem : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEpig8iz7fcL4bjXX+GnhmISIUEjmw vHPv5Pc1baGx8hbcFDdsoeA8cX+MXFv/VaD01vJ9H0WEAlAuq5RhYvSoHw== -----END PUBLIC KEY-----","title":"Core API"},{"location":"mykilio-core-api.html#core-api","text":"This API implements basic resources to provide the base for API aggregation, authentication and authorization. The API is located at: HTTPS: /apis/core.mykil.io/v1alpha1 MQTTS: apis/core.mykil.io/v1alpha1","title":"Core API"},{"location":"mykilio-core-api.html#resources","text":"This sections outlines examples of the resources available as part of this API. This document only contains examples. For the actual JSON schema please refer to THIS (TBD) .","title":"Resources"},{"location":"mykilio-core-api.html#public-key","text":"A public key is used to authenticate things against the platform. They function similarly to the authorized_keys file for on SSH server. apiVersion : baremetal.mykil.io/v1alpha1 kind : PublicKey metadata : name : namespace : spec : signatureScheme : algorithm : ECDSA curve : secp521r1 hash : SHA-512 pem : | -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEpig8iz7fcL4bjXX+GnhmISIUEjmw vHPv5Pc1baGx8hbcFDdsoeA8cX+MXFv/VaD01vJ9H0WEAlAuq5RhYvSoHw== -----END PUBLIC KEY-----","title":"Public key"},{"location":"mykilio-miscellaneous.html","text":"Miscellaneous \u00b6 This document contains drafts, ideas and thoughts that currently can't be assigned to any specific section of the documentation. Kubernetes CRDs \u00b6 In the future, the components of Mycelium could become a part of the Kubernetes API by using Custom Resource Definitions . High level resources \u00b6 This section describes resources that could be used to provision baremetal via high level resources. apiVersion : baremetal.optrin.io/v1alpha1 kind : Plan metadata : name : rpi-4b spec : # TODO: Evaluate overlap with Tinkerbell. apiVersion : baremetal.optrin.io/v1alpha1 kind : Worker metadata : name : rpi4b-0 namespace : test spec : hardware : sku : rpi-4b software : os : codename : ubuntu-focal apiVersion : baremetal.optrin.io/v1alpha1 kind : VirtualNetwork metadata : name : rpi4b-net namespace : test spec : mtu : 1000","title":"Miscellaneous"},{"location":"mykilio-miscellaneous.html#miscellaneous","text":"This document contains drafts, ideas and thoughts that currently can't be assigned to any specific section of the documentation.","title":"Miscellaneous"},{"location":"mykilio-miscellaneous.html#kubernetes-crds","text":"In the future, the components of Mycelium could become a part of the Kubernetes API by using Custom Resource Definitions .","title":"Kubernetes CRDs"},{"location":"mykilio-miscellaneous.html#high-level-resources","text":"This section describes resources that could be used to provision baremetal via high level resources. apiVersion : baremetal.optrin.io/v1alpha1 kind : Plan metadata : name : rpi-4b spec : # TODO: Evaluate overlap with Tinkerbell. apiVersion : baremetal.optrin.io/v1alpha1 kind : Worker metadata : name : rpi4b-0 namespace : test spec : hardware : sku : rpi-4b software : os : codename : ubuntu-focal apiVersion : baremetal.optrin.io/v1alpha1 kind : VirtualNetwork metadata : name : rpi4b-net namespace : test spec : mtu : 1000","title":"High level resources"},{"location":"mykilio-overview.html","text":"Mykilio \u00b6 Mykilio is the proposal for a new Living Standard with the goal to reimagine infrastructure management and monitoring. It aims to be scalable, lightweight, extensible and secure by applying IoT principles to the datacenter and homelabs. Additionally, the goal is to provide a full ecosystem for the development of vendor-agnostic interfaces for infrastructure management and automation. Historically, computing, network and storage infrastructure components are often perceived as highly specialized hardware, that were designed to fulfill the ever-increasing performance, bandwidth and capacity requirements of modern applications. At their core however, an infrastructure component is just another physical object connected to the internet. This becomes even more apparent, when considering a variety of definitions of the Internet of Things created by companies and research papers, which can be summarized as shown below: Internet of Things The Internet of Things is the idea of connecting any physical object to the internet and thereby also to other connected physical objects. This allows to gather enormous amounts of previously unavailable data that can be utilized to develop new services and create additional value. The objective of Mykilio is to bridge the gap between the Internet of Things and modern infrastructure management. Principles \u00b6 Mykilio follows the guiding principles outlined in this section, which are inspired by the popular ideas of Kubernetes and Redfish. The principles serve as the foundation of Mykilio but are, as everything, open for discussion. Eventual consistency \u00b6 As the aforementioned connected physical objects, further described as replicas, form a distributed system one also needs to analyze the consistency model of the system. Considering a set of 0 < n \u2264 N replicas with a shared state S there are two possible choices for the architect of the system. They can either design the system for: strong consistency , where S(1) = S(n) = S(N) . This system is only strongly consistent and fault tolerant and if and only if the state is replicated synchronously and the system enters a read-only mode upon the failure of a single replica. weak consistency , where S(1) ~ S(n) ~ S(N) . This system can tolerate a fault of up to ceil(N / 2 - 1) replicas before being required to enter a read-only mode to remain state consistency. Failures are unavoidable in large-scale distributed systems as every additional component increases the likelihood of a fault 1 . So as to provide reliable and reponsive - read low latency - services to the users of a system, most architects of distributed systems opt for eventual consistency , which is a specific form of weak consistency , where the system converges to the expected state S for t \u2192 \u221e if and only if no changes are applied to the system after t = 0 . Eventually consistent systems are generally harder to implement, because they may require complex consensus algorithms if high-availability and fault tolerance are a requirement. They however also allow the architects to design systems, which can be distributed over long distances (e.g. geo-distribution), connected via unreliable network connections (e.g. cellular networks) or network connections with a high latency (e.g. low-energy wireless protocols) without significantly impacting the user experience. Declarative interface \u00b6 A declarative interface allows the user to specify the desired state while guaranteeing the user that the system will eventually converge towards the desired state if no additional changes are made in the meantime. One major advantage of this is that it hides the complexity of the system from its user. The user is only required to specify the desired state, whereas the system implements the algorithms to modify the current state in such a way that it will converge towards the desired state. This process is often also called reconciliation . All reconciliation logic is hidden from the user and while this adds additional complexity for the implementation of the system, it makes the system safer for the user. Some declarative systems naturally possess self-healing features, such as the ability to automatically recover from failures, a property which provides additional safety and reliability. Principles of Eventual Consistency - Sebastian Burckhardt (2014) \u21a9","title":"Overview"},{"location":"mykilio-overview.html#mykilio","text":"Mykilio is the proposal for a new Living Standard with the goal to reimagine infrastructure management and monitoring. It aims to be scalable, lightweight, extensible and secure by applying IoT principles to the datacenter and homelabs. Additionally, the goal is to provide a full ecosystem for the development of vendor-agnostic interfaces for infrastructure management and automation. Historically, computing, network and storage infrastructure components are often perceived as highly specialized hardware, that were designed to fulfill the ever-increasing performance, bandwidth and capacity requirements of modern applications. At their core however, an infrastructure component is just another physical object connected to the internet. This becomes even more apparent, when considering a variety of definitions of the Internet of Things created by companies and research papers, which can be summarized as shown below: Internet of Things The Internet of Things is the idea of connecting any physical object to the internet and thereby also to other connected physical objects. This allows to gather enormous amounts of previously unavailable data that can be utilized to develop new services and create additional value. The objective of Mykilio is to bridge the gap between the Internet of Things and modern infrastructure management.","title":"Mykilio"},{"location":"mykilio-overview.html#principles","text":"Mykilio follows the guiding principles outlined in this section, which are inspired by the popular ideas of Kubernetes and Redfish. The principles serve as the foundation of Mykilio but are, as everything, open for discussion.","title":"Principles"},{"location":"mykilio-overview.html#eventual-consistency","text":"As the aforementioned connected physical objects, further described as replicas, form a distributed system one also needs to analyze the consistency model of the system. Considering a set of 0 < n \u2264 N replicas with a shared state S there are two possible choices for the architect of the system. They can either design the system for: strong consistency , where S(1) = S(n) = S(N) . This system is only strongly consistent and fault tolerant and if and only if the state is replicated synchronously and the system enters a read-only mode upon the failure of a single replica. weak consistency , where S(1) ~ S(n) ~ S(N) . This system can tolerate a fault of up to ceil(N / 2 - 1) replicas before being required to enter a read-only mode to remain state consistency. Failures are unavoidable in large-scale distributed systems as every additional component increases the likelihood of a fault 1 . So as to provide reliable and reponsive - read low latency - services to the users of a system, most architects of distributed systems opt for eventual consistency , which is a specific form of weak consistency , where the system converges to the expected state S for t \u2192 \u221e if and only if no changes are applied to the system after t = 0 . Eventually consistent systems are generally harder to implement, because they may require complex consensus algorithms if high-availability and fault tolerance are a requirement. They however also allow the architects to design systems, which can be distributed over long distances (e.g. geo-distribution), connected via unreliable network connections (e.g. cellular networks) or network connections with a high latency (e.g. low-energy wireless protocols) without significantly impacting the user experience.","title":"Eventual consistency"},{"location":"mykilio-overview.html#declarative-interface","text":"A declarative interface allows the user to specify the desired state while guaranteeing the user that the system will eventually converge towards the desired state if no additional changes are made in the meantime. One major advantage of this is that it hides the complexity of the system from its user. The user is only required to specify the desired state, whereas the system implements the algorithms to modify the current state in such a way that it will converge towards the desired state. This process is often also called reconciliation . All reconciliation logic is hidden from the user and while this adds additional complexity for the implementation of the system, it makes the system safer for the user. Some declarative systems naturally possess self-healing features, such as the ability to automatically recover from failures, a property which provides additional safety and reliability. Principles of Eventual Consistency - Sebastian Burckhardt (2014) \u21a9","title":"Declarative interface"},{"location":"mykilio-resource-properties.html","text":"Resource properties \u00b6 This document describes common resource properties and how their data is encoded. The resource properties here should be considered first when designing new resources or adding new resource properties to existing resources. Encoding \u00b6 This section explains how different data types are to be encoded. Based on the capabilities of the device, the developer can choose between a binary encoding scheme or a JSON encoding scheme. Enumeration \u00b6 If JSON is used to encode an enumeration, its value is represented as a string . If binary data is used to encode the value, it is represented as an enumerated uint8 . Properties \u00b6 Health \u00b6 The known health of a resource, which is encoded as enumeration and based on Redfish . JSON Binary Description Critical 0 A critical condition requires immediate attention. OK 1 No conditions require special attention. Warning 2 A condition requires attention. Libraries: Go: Health in github.com/nicklasfrahm/mykilio/pkg/props C / C++: mykilio_health_t in embedded/lib/mykilio.h State \u00b6 The known state of the resource, which is encoded as enumeration and based on Redfish . JSON Binary Description Absent 0 This function or resource is either not present or detected. Deferring 1 The element does not process any commands but queues new requests. Disabled 2 This function or resource is disabled. Enabled 3 This function or resource is enabled. InTest 4 This function or resource is undergoing testing, or is in the process of capturing information for debugging. Qualified 5 The element quality is within the acceptable range of operation. Quiesced 6 The element is enabled but only processes a restricted set of commands. StandbyOffline 7 This function or resource is enabled but awaits an external action to activate it. StandbySpare 8 This function or resource is part of a redundancy set and awaits a failover or other external action to activate it. Starting 9 This function or resource is starting. UnavailableOffline 10 This function or resource is present but cannot be used. Updating 11 The element is updating and might be unavailable or degraded. Libraries: Go: State in github.com/nicklasfrahm/mykilio/pkg/props C / C++: mykilio_state_t in embedded/lib/mykilio.h . Manager type \u00b6 The type of manager that this resource represents, which is encoded as enumeration and based on Redfish . JSON Binary Description AuxiliaryController 0 A controller that provides management functions for a particular subsystem or group of devices. BMC 1 A controller that provides management functions for a single computer system. EnclosureManager 2 A controller that provides management functions for a chassis or group of devices or systems. ManagementController 3 A controller that primarily monitors or manages the operation of a device or system. RackManager 4 A controller that provides management functions for a whole or part of a rack. Service 5 A software-based service that provides management functions. Libraries: Go: ManagerType in github.com/nicklasfrahm/mykilio/pkg/props C / C++: mykilio_manager_type_t in embedded/lib/mykilio.h .","title":"Resource properties"},{"location":"mykilio-resource-properties.html#resource-properties","text":"This document describes common resource properties and how their data is encoded. The resource properties here should be considered first when designing new resources or adding new resource properties to existing resources.","title":"Resource properties"},{"location":"mykilio-resource-properties.html#encoding","text":"This section explains how different data types are to be encoded. Based on the capabilities of the device, the developer can choose between a binary encoding scheme or a JSON encoding scheme.","title":"Encoding"},{"location":"mykilio-resource-properties.html#enumeration","text":"If JSON is used to encode an enumeration, its value is represented as a string . If binary data is used to encode the value, it is represented as an enumerated uint8 .","title":"Enumeration"},{"location":"mykilio-resource-properties.html#properties","text":"","title":"Properties"},{"location":"mykilio-resource-properties.html#health","text":"The known health of a resource, which is encoded as enumeration and based on Redfish . JSON Binary Description Critical 0 A critical condition requires immediate attention. OK 1 No conditions require special attention. Warning 2 A condition requires attention. Libraries: Go: Health in github.com/nicklasfrahm/mykilio/pkg/props C / C++: mykilio_health_t in embedded/lib/mykilio.h","title":"Health"},{"location":"mykilio-resource-properties.html#state","text":"The known state of the resource, which is encoded as enumeration and based on Redfish . JSON Binary Description Absent 0 This function or resource is either not present or detected. Deferring 1 The element does not process any commands but queues new requests. Disabled 2 This function or resource is disabled. Enabled 3 This function or resource is enabled. InTest 4 This function or resource is undergoing testing, or is in the process of capturing information for debugging. Qualified 5 The element quality is within the acceptable range of operation. Quiesced 6 The element is enabled but only processes a restricted set of commands. StandbyOffline 7 This function or resource is enabled but awaits an external action to activate it. StandbySpare 8 This function or resource is part of a redundancy set and awaits a failover or other external action to activate it. Starting 9 This function or resource is starting. UnavailableOffline 10 This function or resource is present but cannot be used. Updating 11 The element is updating and might be unavailable or degraded. Libraries: Go: State in github.com/nicklasfrahm/mykilio/pkg/props C / C++: mykilio_state_t in embedded/lib/mykilio.h .","title":"State"},{"location":"mykilio-resource-properties.html#manager-type","text":"The type of manager that this resource represents, which is encoded as enumeration and based on Redfish . JSON Binary Description AuxiliaryController 0 A controller that provides management functions for a particular subsystem or group of devices. BMC 1 A controller that provides management functions for a single computer system. EnclosureManager 2 A controller that provides management functions for a chassis or group of devices or systems. ManagementController 3 A controller that primarily monitors or manages the operation of a device or system. RackManager 4 A controller that provides management functions for a whole or part of a rack. Service 5 A software-based service that provides management functions. Libraries: Go: ManagerType in github.com/nicklasfrahm/mykilio/pkg/props C / C++: mykilio_manager_type_t in embedded/lib/mykilio.h .","title":"Manager type"},{"location":"primo-overview.html","text":"Overview \u00b6 Primo is a cloud platform and reference implementation of the cloud components required to implement Mykilio . Under construction This page is a placeholder, more content is coming soon!","title":"Overview"},{"location":"primo-overview.html#overview","text":"Primo is a cloud platform and reference implementation of the cloud components required to implement Mykilio . Under construction This page is a placeholder, more content is coming soon!","title":"Overview"}]}